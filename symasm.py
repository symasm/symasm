import sys


cc_to_sym = {'a': 'u>', 'ae': 'u>=', 'b': 'u<', 'be': 'u<=', 'c': 'c',
'cxz': 'cx == 0', 'e': '==', 'ecxz': 'ecx == 0', 'g': '>', 'ge': '>=',
'l': '<', 'le': '<=', 'na': '!u>', 'nae': '!u>=', 'nb': '!u<', 'nbe':
'!u<=', 'nc': '!c', 'ne': '!=', 'ng': '!>', 'nge': '!>=', 'nl': '!<',
'nle': '!<=', 'no': '!o', 'np': '!p', 'ns': '!s', 'nz': '!z', 'o':
'o', 'p': 'p', 'rcxz': 'rcx == 0', 's': 's', 'z': 'z'} # generated by [helper_scripts/collect_all_condition_codes.py]

sym_to_cc = {}
for cc, sym in cc_to_sym.items():
    assert(sym not in sym_to_cc)
    sym_to_cc[sym] = cc

cc_to_sym.update({'pe': 'p', 'po': '!p'}) # generated by [helper_scripts/collect_all_condition_codes.py]


if __name__ == '__main__':
    if '-h' in sys.argv or '--help' in sys.argv:
        print(
R'''Symbolic code assembly language translator

Usage: symasm [options] [INPUT_FILE]

Positional arguments:
  INPUT_FILE            input file (STDIN is assumed if no INPUT_FILE is given)

Options:
  -h, --help            show this help message and exit
  -f OUTPUT_FILE, --file OUTPUT_FILE
                        write output to OUTPUT_FILE (defaults to STDOUT)''')
        sys.exit(0)
