compare(int, int):
        xor     eax, eax ; eax = 0
        cmp     edi, esi ; edi <=> esi
        mov     edx, -1  ; edx = -1
        setg    al       ; al = 1 if > else 0
        cmovl   eax, edx ; eax = edx if <
        ret

------------------------------------------

divide(int, int):
        mov     eax, edi ; eax = edi
        cdq              ; edx:eax = sx(eax)
        idiv    esi      ; edx:eax /= esi
        ret

------------------------------------------

divide(long, long):
        mov     rax, rdi ; rax = rdi
        cqo              ; rdx:rax = sx(rax)
        idiv    rsi      ; rdx:rax /= rsi
        ret

------------------------------------------

palindrome_start:
    cmp rcx, 0               ; rcx < 0 : palindrome_end
    jl palindrome_end        ; -
    mov rbx, rdx             ; rbx = rdx
    sub rbx, rcx             ; rbx -= rcx
    sub rbx, 1               ; rbx -= 1
    mov bl, byte [rdi + rbx] ; bl = byte [rdi + rbx]
    cmp byte [rdi + rcx], bl ; byte [rdi + rcx] != bl : palindrome_failed
    jne palindrome_failed    ; -
    dec rcx                  ; rcx--
    jmp palindrome_start     ; :palindrome_start
palindrome_end: